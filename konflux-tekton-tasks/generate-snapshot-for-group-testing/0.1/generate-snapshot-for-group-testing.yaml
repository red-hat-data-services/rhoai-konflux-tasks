apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: trigger-group-testing
spec:
  workspaces:
    - name: basic-auth
      optional: true
    - name: shared-data
  params:
    - name: COMPONENTS
      description: List of components in the group
  results:
  - description: Snapshot json string
    name: SNAPSHOT
  steps:
    - name: generate-snapshot
      image: quay.io/konflux-ci/konflux-test:stable
      workingDir: /workspace
      env:
        - name: COMPONENTS
          value: $(params.COMPONENTS)
        - name: WORKSPACE_BASIC_AUTH_DIRECTORY_BOUND
          value: $(workspaces.basic-auth.bound)
        - name: WORKSPACE_BASIC_AUTH_DIRECTORY_PATH
          value: $(workspaces.basic-auth.path)
        - name: PR_NUMBER
          valueFrom:
            fieldRef:
              fieldPath: metadata.labels['pipelinesascode.tekton.dev/pull-request']
      script: |
        #!/bin/bash
        set -e
        cat /etc/*release
        json_string="$COMPONENTS"
        echo ${COMPONENTS}
        
        # Temporary file to store results
        temp_file=$(mktemp)
        echo "{}" > "$temp_file"

        # Parse JSON and iterate through each component
        while IFS= read -r row; do
            # Tag to search for
            TAG="odh-pr-${PR_NUMBER}"
            FALLBACK_TAG="odh-stable"
        
            # Decode the base64 encoded row
            component=$(echo "$row" | base64 -d | jq -r '.key')
            repo_path=$(echo "$row" | base64 -d | jq -r '.value')
            
            echo "component=${component}"
            echo "repo_path=${repo_path}"
        
            if skopeo inspect "docker://quay.io/${repo_path}:${TAG}" &>/dev/null; then
              echo "found the image with tag ${TAG}"
            else
              echo "No image found with tag ${TAG}, falling back to the ${FALLBACK_TAG} image for ${repo_path}"
              TAG=${FALLBACK_TAG}
            fi
                
            
            # Construct full quay URL
            full_repo="quay.io/${repo_path}"

            echo "Processing component: $component" >&2
            echo "Repository: $full_repo" >&2

            # Extract namespace and repository name from repo_path
            # Format: namespace/project/repository
            namespace=${repo_path%/*}
            repository=${repo_path##*/}

            # Query Quay API to get the digest for the tag
            api_url="https://quay.io/api/v1/repository/${namespace}/${repository}/tag/?specificTag=${TAG}"

            echo "Querying: $api_url" >&2

            # Make API request and extract the manifest digest
            response=$(curl -s "$api_url")

            # Get the latest (first) tag's manifest digest
            manifest_digest=$(echo "$response" | jq -r '.tags[0].manifest_digest // empty')

            if [ -z "$manifest_digest" ]; then
                echo "Warning: No digest found for $component with tag $TAG" >&2
                full_image_uri="${full_repo}:${TAG}"
                git_url=""
                git_commit=""
            else
                echo "Found digest: $manifest_digest" >&2
                full_image_uri="${full_repo}@${manifest_digest}"

                # Query Quay API to get the manifest details and extract labels
                manifest_api_url="https://quay.io/api/v1/repository/${namespace}/${repository}/manifest/${manifest_digest}"
                echo "Querying manifest: $manifest_api_url" >&2

                manifest_response=$(curl -s "$manifest_api_url")
                echo "manifest_response=${manifest_response}" >&2

                # Check if this is a manifest list (multi-arch image)
                is_manifest_list=$(echo "$manifest_response" | jq -r '.is_manifest_list // false')
                echo "Is manifest list: $is_manifest_list" >&2

                if [ "$is_manifest_list" = "true" ]; then
                    echo "Multi-arch image detected, extracting first manifest digest" >&2

                    # Get the digest of the first manifest in the list
                    first_manifest_digest=$(echo "$manifest_response" | jq -r '.manifest_data' | jq -r '.manifests[0].digest // empty')

                    if [ -z "$first_manifest_digest" ]; then
                        echo "Warning: No manifest found in manifest list" >&2
                        git_url=""
                        git_commit=""
                    else
                        echo "First manifest digest: $first_manifest_digest" >&2

                        # Query API again with the specific manifest digest
                        specific_manifest_api_url="https://quay.io/api/v1/repository/${namespace}/${repository}/manifest/${first_manifest_digest}/labels"
                        echo "Querying specific manifest: $specific_manifest_api_url" >&2

                        specific_manifest_response=$(curl -s "$specific_manifest_api_url")
                        echo "specific_manifest_response=${specific_manifest_response}"
                        # Extract git.url and git.commit labels from the specific manifest
                        git_url=$(echo "$specific_manifest_response" | jq -r '.labels[] | select(.key == "git.url") | .value// empty')
                        git_commit=$(echo "$specific_manifest_response" | jq -r '.labels[] | select(.key == "git.commit") | .value// empty')
                    fi
                else
                    echo "Single-arch image, extracting labels directly" >&2

                    # Extract git.url and git.commit labels from current manifest
                    git_url=$(echo "$manifest_response" | jq -r '.config.config.Labels["git.url"] // empty')
                    git_commit=$(echo "$manifest_response" | jq -r '.config.config.Labels["git.commit"] // empty')
                fi

                echo "Git URL: $git_url" >&2
                echo "Git Commit: $git_commit" >&2
            fi

            # Add to output JSON with image URI, git.url, and git.commit
            jq --arg key "$component" \
               --arg image "$full_image_uri" \
               --arg giturl "$git_url" \
               --arg gitcommit "$git_commit" \
               --arg image_tag "$TAG" \
               '. + {($key): {image: $image, "git.url": $giturl, "git.commit": $gitcommit, "image_tag": $image_tag}}' \
               "$temp_file" > "${temp_file}.tmp" && mv "${temp_file}.tmp" "$temp_file"

            echo "" >&2
        done < <(echo "$json_string" | jq -r 'to_entries[] | @base64')

        # Print final output JSON
        echo "Output JSON:" >&2
        cat "$temp_file" | jq '.'
        if ! echo -en $(cat "$temp_file") > "$(results.SNAPSHOT.path)"; then
            echo "writing the snapshot to a file since cannot write to the result.."
            echo -en $(cat "$temp_file") >  $(workspaces.shared-data.path)/group-snapshot.json
            echo -en "$(workspaces.shared-data.path)/group-snapshot.json" > "$(results.SNAPSHOT.path)"
            echo "successfully saved the snapshot to $(workspaces.shared-data.path)/group-snapshot.json"
        fi
        
        # Cleanup
        rm -f "$temp_file"