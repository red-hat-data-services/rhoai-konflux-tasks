apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: rhoai-init
spec:
  params:
  - name: expected-cluster
    type: string
    default: ""
  - name: build-type
    description: FBC build type. It can be one of 'nightly', 'stage', or 'ci'.
    type: string
    default: ""
  - default: ''
    description: RHOAI version of the form X.Y.Z or X.Y.Z-suffix (e.g., 3.2.1 or 3.4.0-ea.1). Optional for PR pipelines.
    name: rhoai-version
    type: string
  - name: image-output
    description: Fully qualified output image (e.g., quay.io/rhoai/odh-trustyai-nemo-guardrails-server-rhel9:rhoai-3.3)
    type: string
    default: ""
  results:
  - description: Notification text to be posted to slack
    name: slack-message-failure-text
  - description: Skip slack message
    name: skip-slack-message
  - description: cpe id for the built image
    name: cpe-id
  - description: Image registry (e.g., quay.io)
    name: image-registry
  - description: Image namespace/organization (e.g., rhoai)
    name: image-namespace
  - description: Image name without tag (e.g., odh-trustyai-nemo-guardrails-server-rhel9)
    name: image-name
  - description: Image tag (e.g., rhoai-3.3)
    name: image-tag
  - description: Image name without rhel suffix (e.g., odh-trustyai-nemo-guardrails-server)
    name: image-name-without-rhel-suffix
  - description: Konflux component name (e.g., odh-trustyai-nemo-guardrails-server-v3-3)
    name: konflux-component-name
  - description: Human-readable display name (e.g., Odh Trustyai Nemo Guardrails Server)
    name: display-name
  steps:
  - image: registry.access.redhat.com/ubi9/ubi:latest
    name: rhoai-init
    env:
    - name: slack_message
      valueFrom:
        secretKeyRef:
          name: rhoai-konflux-secret
          key: slack-component-failure-notification
    - name: target_branch
      valueFrom:
        fieldRef:
          fieldPath: metadata.annotations['build.appstudio.redhat.com/target_branch']
    - name: EXPECTED_CLUSTER
      value: $(params.expected-cluster)
    - name: BUILD_TYPE
      value: $(params.build-type)
    - name: RHOAI_VERSION
      value: $(params.rhoai-version)
    - name: IMAGE_OUTPUT
      value: $(params.image-output)
    - name: BUILD_URL
      valueFrom:
        fieldRef:
          fieldPath: metadata.annotations['pipelinesascode.tekton.dev/log-url']
    - name: SHA_URL
      valueFrom:
        fieldRef:
          fieldPath: metadata.annotations['pipelinesascode.tekton.dev/sha-url']
    - name: SUMMARY_ANNOTATIONS
      valueFrom:
        fieldRef:
          fieldPath: metadata.annotations['results.tekton.dev/recordSummaryAnnotations']
    - name: KONFLUX_COMPONENT_NAME
      valueFrom:
        fieldRef:
          fieldPath: metadata.labels['appstudio.openshift.io/component']
    script: |
      echo "----- DEBUG INFORMATION -----"
      echo "Build URL: $BUILD_URL"
      echo "SHA URL: $SHA_URL"
      echo "Target Branch: $target_branch"
      echo "Summary Annotations: $SUMMARY_ANNOTATIONS"
      echo "Build Type: $BUILD_TYPE"
      echo "RHOAI Version: $RHOAI_VERSION"
      echo "Image Output: $IMAGE_OUTPUT"
      echo "Expected Cluster: $EXPECTED_CLUSTER"
      echo "Konflux Component Name: $KONFLUX_COMPONENT_NAME"

      # Check if this is a pull request pipeline
      is_pull_request=false
      if [[ "$SUMMARY_ANNOTATIONS" =~ '"eventType":"pull_request"' ]]; then
        is_pull_request=true
        echo "Pull request pipeline detected"
      fi

      # Fail if required parameters are not provided
      # rhoai-version is optional for PR pipelines
      if [[ -z "$RHOAI_VERSION" && "$is_pull_request" == "false" ]]; then
        echo "ERROR: RHOAI version is required but was not provided"
        exit 1
      fi

      if [[ -z "$IMAGE_OUTPUT" ]]; then
        echo "ERROR: Image output is required but was not provided"
        exit 1
      fi

      pipelinerun_name=$(echo $BUILD_URL | sed 's|http.*/||')
      echo "Pipelinerun Name: $pipelinerun_name"

      # Function to compare semantic versions
      # returns true (0) if $1 >= $2
      semver_ge() {
          # Strip pre-release suffix (e.g., "3.4.0-ea.1" becomes "3.4.0")
          local v1="${1%%-*}"
          local v2="${2%%-*}"

          # We append ".0.0" to ensure at least three components (x.y.z) exist.
          # This normalizes both versions ($1 and $2) to x.y.z format for comparison.
          # We read four variables (x1, y1, z1, extra) to ensure x1, y1 and z1 only captures the x, y and z,
          # and the dummy variable (extra) captures the extra trailing ".0" parts.
          IFS='.' read -r x1 y1 z1 extra <<< "${v1}.0.0"
          IFS='.' read -r x2 y2 z2 extra <<< "${v2}.0.0"

          echo "Comparing versions: $1 (normalized to x1=$x1, y1=$y1, z1=$z1) and $2 (normalized to x2=$x2, y2=$y2, z2=$z2)"

          if (( x1 > x2 )); then return 0; fi
          if (( x1 < x2 )); then return 1; fi

          if (( y1 > y2 )); then return 0; fi
          if (( y1 < y2 )); then return 1; fi

          if (( z1 >= z2 )); then return 0; fi

          return 1
      }

      # No need to set CPE ID for pull request builds
      if [[ ! "$SUMMARY_ANNOTATIONS" =~ '"eventType":"pull_request"' ]]; then

        # All RHOAI versions 2.20 and above use RHEL 9
        # Determine rhel_version based on semantic comparison with 2.20
        if semver_ge "$RHOAI_VERSION" "2.20"; then
            rhel_version=9
        else
            rhel_version=8
        fi

        # Parse RHOAI version into x, y, z components for CPE ID
        # Strip pre-release suffix first (e.g., "3.4.0-ea.1" becomes "3.4.0")
        clean_version="${RHOAI_VERSION%%-*}"
        IFS='.' read -r x y z extra <<< "${clean_version}.0.0"

        # Form the CPE identifier
        cpe_id="cpe:/a:redhat:openshift_ai:${x}.${y}::el${rhel_version}"
      else
        cpe_id=""
      fi

      echo "CPE ID: $cpe_id"
      echo -n "${cpe_id}" > "$(results.cpe-id.path)"

      # Extract image registry, namespace, name and tag from the image-output parameter
      # Supports both 2-level and 3-level paths:
      #   quay.io/rhoai/image-name:tag -> registry=quay.io, namespace=rhoai, name=image-name
      #   quay.io/redhat-user-workloads/rhoai-tenant/image-name:tag -> registry=quay.io, namespace=redhat-user-workloads/rhoai-tenant, name=image-name
      echo "----- PARSING IMAGE OUTPUT -----"

      # Extract registry (first part before the first /)
      image_registry=$(echo "$IMAGE_OUTPUT" | cut -d'/' -f1)

      # Remove registry to get the rest (namespace/path/image:tag)
      image_path_with_tag="${IMAGE_OUTPUT#*/}"

      # Split off the tag first (everything after the last :)
      if [[ "$image_path_with_tag" == *":"* ]]; then
        image_path=$(echo "$image_path_with_tag" | rev | cut -d':' -f2- | rev)
        image_tag=$(echo "$image_path_with_tag" | rev | cut -d':' -f1 | rev)
      else
        image_path="$image_path_with_tag"
        image_tag=""
      fi

      # Extract image name (last component of the path)
      image_name=$(echo "$image_path" | rev | cut -d'/' -f1 | rev)

      # Extract namespace (everything before the image name)
      image_namespace=$(echo "$image_path" | rev | cut -d'/' -f2- | rev)

      echo "Image Registry: $image_registry"
      echo "Image Namespace: $image_namespace"
      echo "Image Name: $image_name"
      echo "Image Tag: $image_tag"

      # Derive additional values from image_name
      # image_name_without_rhel_suffix: Remove -rhel{N} suffix from anywhere in image_name
      image_name_without_rhel_suffix=$(echo "$image_name" | sed 's/-rhel[0-9]*//g')

      # display_name: Convert image_name_without_rhel_suffix to human-readable display name
      # Replace hyphens with spaces, capitalize first letter of each word, keep ODH uppercase
      display_name=$(echo "$image_name_without_rhel_suffix" | tr '-' ' ' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) tolower(substr($i,2)); print}' | sed 's/\bOdh\b/ODH/g')

      echo "Image Name Without RHEL Suffix: $image_name_without_rhel_suffix"
      echo "Display Name: $display_name"

      echo -n "${image_registry}" > "$(results.image-registry.path)"
      echo -n "${image_namespace}" > "$(results.image-namespace.path)"
      echo -n "${image_name}" > "$(results.image-name.path)"
      echo -n "${image_tag}" > "$(results.image-tag.path)"
      echo -n "${image_name_without_rhel_suffix}" > "$(results.image-name-without-rhel-suffix.path)"
      echo -n "${KONFLUX_COMPONENT_NAME}" > "$(results.konflux-component-name.path)"
      echo -n "${display_name}" > "$(results.display-name.path)"
      
      # Skip slack message if expected cluster does not match
      CLUSTER=$( echo "$BUILD_URL" | grep -oE 'stone-pro?d-[a-z0-9]+')
      echo "Expected Cluster: $EXPECTED_CLUSTER"
      echo "Actual Cluster: $CLUSTER"
      if [[ -n "$EXPECTED_CLUSTER" && "$EXPECTED_CLUSTER" != "$CLUSTER" ]]; then
        echo "Build URL does not match expected cluster $CLUSTER."
        echo -n "true" > "$(results.skip-slack-message.path)"
      else
        echo -n "false" > "$(results.skip-slack-message.path)"
      fi

      build_time="$(date +%Y-%m-%dT%H:%M:%S)"

      slack_message=${slack_message/__BUILD__URL__/$BUILD_URL}
      slack_message=${slack_message/__PIPELINERUN__NAME__/$pipelinerun_name}
      slack_message=${slack_message/__BUILD__TIME__/$build_time}

      # Don't send a slack message for pull request pipelines
      if [[ "$SUMMARY_ANNOTATIONS" =~ "pull_request-id" ]]; then
        echo "pull request pipeline detected, skipping slack message"
        echo -n "true" > "$(results.skip-slack-message.path)"
      fi

      # Tag @rhoai-releng for stage FBCF build failures
      if [[ "$BUILD_TYPE" == "stage" ]]; then
        alertEmoji=":actual_rotating_light:"
        slack_message=${slack_message/:alert:/$alertEmoji}
        # The "!" in <!subteam^S09SZP9J34M|rhoai-releng> causes Bash history expansion errors
        set +H  # disable history expansion
        slack_message=$(echo -e "${slack_message}\nCC - <!subteam^S09SZP9J34M|rhoai-releng>")
        set -H  # re-enable history expansion
      fi

      echo -en "${slack_message}" > "$(results.slack-message-failure-text.path)"
      echo "Slack Message: ${slack_message}"
