apiVersion: tekton.dev/v1alpha1
kind: StepAction
metadata:
  name: secure-git-push
  labels:
    upstream-usable: "true"
spec:
  description: |
    This StepAction scans specified directory (workingDir) using [leaktk-scanner CLI](https://github.com/leaktk/scanner)
    and deletes files containing sensitive information (credentials, certificates) that shouldn't be exposed to public.
    Then it pushes the working directory contents to a specified git repo.
  image: quay.io/konflux-qe-incubator/konflux-qe-tools:latest
  params:
    - name: repo-path
      type: string
    - name: repo-branch
      type: string
    - name: sparse-file-path
      type: string
      default: ""
    - name: source-path
      type: string
    - name: dest-path
      type: string
    - name: always-pass
      type: string
      default: "false"
    - name: pipelinerun-name
      type: string
  workingDir: /workspace/odh-ci-artifacts
  env:
    - name: REPO_PATH
      value: "$(params.repo-path)"
    - name: REPO_BRANCH
      value: "$(params.repo-branch)"
    - name: SPARSE_FILE_PATH
      value: "$(params.sparse-file-path)"
    - name: SOURCE_PATH
      value: "$(params.source-path)"
    - name: DEST_PATH
      value: "$(params.dest-path)"
    - name: ALWAYS_PASS
      value: "$(params.always-pass)"
    - name: WORK_DIR
      value: /workspace/odh-ci-artifacts
    - name: WORKSPACE_BASIC_AUTH_DIRECTORY_BOUND
      value: $(workspaces.basic-auth.bound)
    - name: WORKSPACE_BASIC_AUTH_DIRECTORY_PATH
      value: $(workspaces.basic-auth.path)
    - name: TASK_NAME
      value: $(context.task.name)
    - name: PIPELINERUN_NAME
      value: "$(params.pipelinerun-name)"
    - name: GITHUB_TOKEN
      valueFrom:
        secretKeyRef:
          name: odh-github-secret
          key: build-metadata-token
  script: |
    #!/bin/bash
    set -e

    echo "WORK_DIR: $WORK_DIR"
    echo "REPO_PATH: $REPO_PATH"
    echo "REPO_BRANCH: $REPO_BRANCH"
    echo "SPARSE_FILE_PATH: $SPARSE_FILE_PATH"
    echo "SOURCE_PATH: $SOURCE_PATH"
    echo "DEST_PATH: $DEST_PATH"
    echo "ALWAYS_PASS: $ALWAYS_PASS"

    main() {
              
          if [ "${WORKSPACE_BASIC_AUTH_DIRECTORY_BOUND}" = "true" ]; then
            echo "configuring gh token"
            # GITHUB_TOKEN=$(cat "${WORKSPACE_BASIC_AUTH_DIRECTORY_PATH}/git-provider-token")
            echo "taking github token from Konflux bot"
          fi
          if [ -z "$GITHUB_TOKEN" ]; then
              echo "Error: GITHUB_TOKEN env is not set."
              exit 1
          fi
    
          mkdir -p ${WORK_DIR}
          cd ${WORK_DIR}
          git config --global init.defaultBranch ${REPO_BRANCH}
          git config --global user.name "OpenShift-AI-DevOps"
          git config --global user.email "openshift-ai-devops@redhat.com"
          git init
          git config --global --add safe.directory ${WORK_DIR}
          git remote add origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${REPO_PATH}.git"
          if [[ -n "${SPARSE_FILE_PATH}" ]]; then
              git config core.sparseCheckout true
              git config core.sparseCheckoutCone false
              echo "${SPARSE_FILE_PATH}" >> .git/info/sparse-checkout
          fi
          git fetch --depth=1 origin ${REPO_BRANCH}
          git checkout ${REPO_BRANCH}
    
          
          cd ${SOURCE_PATH}

          
          # Scan the working directory using leaktk-scanner and remove problematic files
          log_filename="leaktk-scan-$(date +%s).log"
          leaktk-scanner scan --kind Files --resource . 2>> $log_filename | leaktk-remove-files . &>> $log_filename
    
          # ARTIFACT_DIR_NAME=$(basename "$(pwd)")
          # cd ../
    
          echo "TASK_NAME=${TASK_NAME}"
          echo "PIPELINERUN_NAME=${PIPELINERUN_NAME}"
    
          TASK_NAME=${TASK_NAME/${PIPELINERUN_NAME}-/}
          git -C ${WORK_DIR} pull --no-edit origin ${REPO_BRANCH}
          mkdir -p ${WORK_DIR}/${DEST_PATH}
          tar -czf "${WORK_DIR}/${DEST_PATH}/${TASK_NAME}.tar.gz" .
          ls -l "${WORK_DIR}/${DEST_PATH}/${TASK_NAME}.tar.gz"
    
          
          # cp "${TASK_NAME}.tar.gz" ${WORK_DIR}/${DEST_PATH}

          cd ${WORK_DIR}
          #push the changes to remote
          git add --sparse ${WORK_DIR}/${DEST_PATH}
          git commit -m "Updating CI Artifacts in ${TASK_NAME}"
          git pull --no-edit origin ${REPO_BRANCH}
          git push

    }
    if [[ ! -d "${SOURCE_PATH}" ]] || [[ -d "${SOURCE_PATH}" && -z "$(ls -A ${SOURCE_PATH})" ]]; then
        echo "SKIP" > /workspace/status
        echo "exiting since no CI artifacts found.."
        exit 0
    fi
    if [ "$ALWAYS_PASS" == "true" ]; then
      main || true
    else
      main
    fi
